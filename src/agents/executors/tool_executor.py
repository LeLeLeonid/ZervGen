from pathlib import Path
from ...tools.pollinations_client import PollinationsClient

class ToolExecutor:
    """Executes tool calls from a plan generated by the Supervisor."""
    def __init__(self, client: PollinationsClient):
        self.client = client
        self.output_dir = Path("outputs")
        self.output_dir.mkdir(exist_ok=True)

        self._dispatcher = {
            "generate_image": self.execute_generate_image,
            "generate_text": self.execute_generate_text,
        }
        self.last_text_result = ""

    def execute_step(self, step: dict) -> str:
        """Executes a single step from the plan."""
        tool_name = step.get("tool_name")
        params = step.get("params", {})
        
        if not tool_name:
            raise ValueError("Step in plan is missing a 'tool_name'.")
            
        handler = self._dispatcher.get(tool_name)
        if not handler:
            raise ValueError(f"Executor does not know how to handle tool: '{tool_name}'")

        if isinstance(params.get("prompt"), str) and "previous step" in params["prompt"].lower():
            print("(Pipe detected: Using output from previous step as prompt)")
            params["prompt"] = self.last_text_result
            
        result = handler(**params)

        if tool_name == "generate_text":
            self.last_text_result = result

        return result

    def execute_generate_image(self, **params) -> str:
        """Handler for the 'generate_image' tool."""
        if 'prompt' not in params:
            raise ValueError("Image generation requires a 'prompt' parameter.")
        
        image_bytes = self.client.generate_image(**params)
        
        prompt_for_filename = params.get('prompt', 'image')
        safe_filename = "".join(c for c in prompt_for_filename if c.isalnum() or c in " _-").rstrip()[:50]
        output_path = self.output_dir / f"{safe_filename}.jpg"
        
        with open(output_path, "wb") as f:
            f.write(image_bytes)
        
        return f"Image successfully saved to '{output_path.resolve()}'"

    def execute_generate_text(self, **params) -> str:
        """Handler for the 'generate_text' tool."""
        if 'prompt' not in params:
            raise ValueError("Text generation requires a 'prompt' parameter.")
        
        return self.client.generate_text(**params)