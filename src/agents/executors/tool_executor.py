import json
import logging
from pathlib import Path
from ...tools.pollinations_client import PollinationsClient, ApiClientError

class ToolExecutor:
    """Executes tool calls from a plan generated by the Supervisor."""
    def __init__(self, client: PollinationsClient):
        self.client = client
        self.output_dir = Path("outputs")

        self.patterns_dir = Path("src/patterns")
        self.explanations_path = self.patterns_dir / "explanations.json"
        
        self.output_dir.mkdir(exist_ok=True)
        self.patterns_dir.mkdir(exist_ok=True)
        (self.patterns_dir / "data").mkdir(exist_ok=True) # Ensure the data subdirectory exists

        self._dispatcher = {
            "generate_image": self.execute_generate_image,
            "generate_text": self.execute_generate_text,
            "generate_pattern": self.execute_generate_pattern, # Make sure this tool name matches the plan
        }
        self.last_text_result = ""

    def execute_step(self, step: dict) -> str:
        """Executes a single step from the plan."""
        tool_name = step.get("tool_name")
        params = step.get("params", {})
        
        if not tool_name:
            raise ValueError("Step in plan is missing a 'tool_name'.")
            
        handler = self._dispatcher.get(tool_name)
        if not handler:
            raise ValueError(f"Executor does not know how to handle tool: '{tool_name}'")

        if isinstance(params.get("prompt"), str) and "previous step" in params["prompt"].lower():
            params["prompt"] = self.last_text_result
            
        result = handler(**params)

        if tool_name == "generate_text":
            self.last_text_result = result

        return result

    def execute_generate_image(self, **params) -> str:
        """Handler for the 'generate_image' tool."""
        if 'prompt' not in params:
            raise ValueError("Image generation requires a 'prompt' parameter.")
        
        image_bytes = self.client.generate_image(**params)
        
        prompt_for_filename = params.get('prompt', 'image')
        safe_filename = "".join(c for c in prompt_for_filename if c.isalnum() or c in " _-").rstrip()[:50]
        output_path = self.output_dir / f"{safe_filename}.jpg"
        
        with open(output_path, "wb") as f:
            f.write(image_bytes)
        
        return f"Image successfully saved to '{output_path.resolve()}'"

    def execute_generate_text(self, **params) -> str:
        """Handler for the 'generate_text' tool."""
        if 'prompt' not in params:
            raise ValueError("Text generation requires a 'prompt' parameter.")
        
        return self.client.generate_text(**params)

    def execute_generate_pattern(self, **params) -> str:
        """Handler for the 'generate_pattern' tool."""
        pattern_name = params.get('pattern_name')
        explanation = params.get('explanation')
        pattern_content = self.last_text_result

        if not all([pattern_name, explanation, pattern_content]):
            raise ValueError("generate_pattern requires 'pattern_name', 'explanation', and content from the previous step.")

        pattern_file = self.patterns_dir / "data" / f"{pattern_name}.md"
        pattern_file.write_text(pattern_content, encoding='utf-8')

        try:
            if not self.explanations_path.exists():
                data = {}
            else:
                try:
                    with open(self.explanations_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                except json.JSONDecodeError:
                    data = {} # Reset if corrupt

            data[pattern_name] = explanation
            
            with open(self.explanations_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
        except IOError as e:
            logging.error(f"Failed to write to explanations.json: {e}")
        
        return f"Successfully saved new pattern '{pattern_name}' and updated explanations."
    
    def execute_transcribe_youtube(self, **params) -> str:
        """Handler for the 'transcribe_youtube' tool."""
        if 'url' not in params:
            raise ValueError("YouTube transcription requires a 'url' parameter.")
        return self.client.transcribe_youtube(url=params['url'])